+
LAMBDA FUNCTION:-
-A lambda function is a small anonymous function.

-A lambda function can take any number of arguments, but can only have one expression.

lambda arguments : expression

-def cube(y):
   return y*y*y
 
cube=lambda y:y*y*y
print(cube(5))
e.g-x = lambda a : a + 10
print(x(5))

e.g-x = lambda a, b : a * b
print(x(5, 6))
or
(lambda a,b:a*b)(5,6)
-lambda function with if else--
e.g-max=lambda a,b:a if(a>b) else b
    print(max(1,2))
Q>WAP to find square of given no.






s=lambda n:n*n
print("result",s(4))

CONFIG FILES:
=>Configuration files contain requirements, settings, dependencies, and preferences for a software program or application.
=> These files can be used to specify the settings for software, based on the system configuration. 
=>Normally, configuration files contain specific information in the format of key-value pairs. 
=>The information can be stored in a simple text file using specific file formats, such as INI, XML, or json, depending on the requirements.
=>one approach to use the builtin 'configparser'module,especially for ini style configuration file.
=>Create a file"config.ini"
-INI files are most often used in the Windows file system.
- Each INI configuration file is structured in the form of sections and fields. 
-Each file contains different sections, and each section contains different fields with values associated with them
        [database]
        host=localhost
        port=5432
        username=myusername
        password=mypassword
        [paths]
        data_path=/path/to/data
        log_path=/path/to/logs 
 =>you can read this file using"configparser"module as follows-
        import configparser
        config= configparser.ConfigParser()  #Create a configparser object
        config.read('config.ini')            #read configuration file
        database_host=config['database']['host'] #Access values in config file
        data_path=config['paths']['data_path']
      # log_path= config.get('paths', 'log_path')

        print("database host:",database_host)
        print("data path:",data_path)
LOG FILES:
=>These files that store records of events,messages or activities generated by system,application or process.
These records known as log entries  or log messages.
=>Log files capture information about operation of the system or application including errors,warnings,informational messages,
debug output etc.
=>The defined levels, in order of increasing severity, are the following:

-DEBUG(lowest level)
-INFO(second lowest)
-WARNING(default level)
-ERROR
-CRITICAL


=>The following code snippet shows how you can use all the five logging levels with the syntax: logging.<level>(<message>)

   logging.debug("A DEBUG Message")
   logging.info("An INFO")
   logging.warning("A WARNING")
   logging.error("An ERROR")
   logging.critical("A message of CRITICAL severity")

You’ll see that the messages corresponding to warning, error, and critical are logged onto the console, whereas debug and info are not.
output:

     WARNING:root:A WARNING
     ERROR:root:An ERROR
     CRITICAL:root:A message of CRITICAL severity

This is because, by default, only messages corresponding to a logging level of warning and above are logged onto the console.
 However, you can modify this by configuring the logger to start logging from a specific level of your choosing.


=>In python you can write log files using builtin "logging" module
=>Create a file"file.py"
      import logging


Q>Write a Python program to create a log file and write INFO and higher 
level messages?
     import logging 
     logging.basicConfig(filename='log.txt',level=logging.INFO) 
     print("Logging Module Demo") 
     logging.debug("This is debug message") 
     logging.info("This is info message") 
     logging.warning("This is warning message") 
     logging.error("This is error message") 
     logging.critical("This is critical message")

 
log.txt:
 INFO:root:This is info message
 WARNING:root:This is warning message 
 ERROR:root:This is error message 
 CRITICAL:root:This is critical message
PYTHON FILE OPERATION:-
1>opening  a file:
.you can open a file using built in'open()'function.
.it takes  2 parameters(file name,mode of opening a file)
e.g-file1 = open("file1.txt","r")
.Opening a Python File Using with...open->    
In Python, there is a better way to open a file using with...open.
The with statement can be used
 while opening a file.
We can use this to group file 
operation statements within a block.
The advantage of with statement is it will take care closing of file,
after completing all 
operations automatically even in the case of exceptions also, 
and we are not required to 
close explicitly. For example,

    with open("file1.txt", "r") as file1:
       read_content = file1.read()
       print(read_content)

*Note:-
r: open an existing file for a read operation.
w: open an existing file for a write operation. If the file already contains some data, then
 it will be overridden but
 if the file is not present then it creates the file as well.
a:  open an existing file for append operation. It won’t override existing data.
r+:  To read and write data into the file. The previous data in the
 file will be overridden.
w+: To write and read data. It will override existing data.
a+: To append and read data from the file. It won’t override existing data.




2>reading from a file:
.once you have opened a file for reading,you can read it's contents using methods like read(),
readline(),readlines().
e.g-# open a file in read mode
   file1 = open("file1.txt")

   # read the file content
   read_content = file1.read()
   print(read_content)

Q>To read only first 10 characters:


      f=open("abc.txt",'r') 
      data=f.read(10) 
      print(data) 
      f.close()

3>writing to a file:
.to write  to a file,open it in write mode('w') or append mode('a') and 
use methods like 
write(str) and writelines()


 e.g-# open the file2.txt in write mode(overwrite data)
     file2 = open('file2.txt', 'w')

     # write contents to the file2.txt file
     file2.write('Programming is Fun.\n')
     file2.write('Programiz for beginners\n')
or
    # Open 'file.txt' in append mode ('a')
    file = open('file.txt', 'a')

    # Write contents to the file
    file.write('Programming is Fun.\n')
    file.write('Programiz for beginners\n')

     # Close the file
    file.close()

 
Q> Write a python program that writes “Hello world” into a file.







    f =open("file.txt",'w')

    f.write("hello world")

    f.close()
     


Q>Write a Python program to append text to a file and display the text.(h.w)
4>Closing a file:
      e.g-# open a file
       file1 = open("file1.txt", "r")

       # read the file
       read_content = file1.read()
       print(read_content)

       # close the file
       file1.close()

5>checking the existence:
.We can use os library to get information about files in our computer.
os module has path sub module,which contains isFile() function to check whether a 
particular file exists or not?
os.path.isfile(fname)

NOTE:-
--tell():
==>We can use tell() method to return current position of the cursor(file pointer) from 
beginning of the file.
Eg:
      f=open("file.txt","r") 
      print(f.tell()) 
      print(f.read(2)) 
      print(f.tell()) 
      print(f.read(3)) 
      print(f.tell()) 
-file.txt
   hello
   good
   bad
   bye
6>moving file pointer:
...you can use seek() method to move a file pointer to a specific position within a file.
.The file pointer represents the current position in the file where next read or write operation will occur.
.seek()method sets the current file position in a file stream.
    file.seek(no.of positions to move forward,point of reference)
 
0-sets reference point at beginning of file.
1-sets reference point at current file position.
2-sets reference point at end of file.
Q>Change the current file position to 20, and return the rest of the line:

 demofile.txt-

"code is like humor, when you have to explain it,  it's good."

   f = open("demofile.txt", "r")
   f.seek(20)
   print(f.tell())
   print(f.read())
   f.close()

OUTPUT:-
20
when you have to explain it,  it's good."

...seek() function with -ve offset only works when a file is opened in binary mode.
   f=open("data.txt","rb")   #opening data.txt file to binary mode
   f.seek(-10,2)             #sets reference point to tenth position to left from end.
   print(f.tell())
   print(f.readline().decode('utf-8'))
   f.close()
   
OUTPUT:-
52
t's good."

 

=>read functions, read(), readline() and readlines():
-read()-
.The read() method returns the specified number of bytes from the file.
. Default is -1 which means the whole file.
         file.read()

-f=open('file.txt')
print(f.read(5))
print(f.read(5))
f.tell()

-f=open('file.txt')
f.seek(15)
f.read(5)

-f=open('file.txt')#to print text file line by line
f.seek(0)
for line in f:
    print(line)


-readline()-
.Python readline() method will return a line from the file when called.


f=open('file.txt')
f.readline()



-readlines()-
.readlines() method will return all the lines in a file in the format of a list 
where each element is a line in the file.

f=open('file.txt')
f.readlines()



-writelines()-
.The writelines() method writes the items of a list to the file.

.Where the texts will be inserted depends on the file mode and stream position.

"a":  The texts will be inserted at the current file stream position,
 default at the end of the file.

"w": The file will be emptied before the texts will be inserted at the current file stream position, default 0.

Syntax
file.writelines(listof lines)


f=open("file.txt",'w') 
list=["sunny\n","bunny\n","vinny\n","chinny"] 
f.writelines(list) 
print("List of lines written to the file successfully") 
f.close()



